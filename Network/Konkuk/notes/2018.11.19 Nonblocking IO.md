# 2018.11.19 Nonblocking I/O

- ### 쓰는 이유

  - 매 요청마다 스레드를 생성하는 것은 높은 오버헤드를 발생시킬 수 있다.

    > 해결 방법 : **스레드 풀**, **nonblocking I/O**

  - **Blocking I/O** : 내가 원하는 결과를 받을 때까지 block된 상태로 대기하는 것

    - ex) **ServerSocket.wait()** 메소드, **InputStream.read()** 메소드
    - CPU가 어떻게 스케줄링 되는지에 따라서 다른 스레드가 CPU의 리소스를 잡아서 내가 할 일을 할 수가 있지만, 여기서 **스레드가 너무 많을 경우 오버헤드가 발생하게 되는 것**
    - CPU가 blocking 되면서 낭비되는 시간을 줄이는 것이 필요하게 됨!

  - **Nonblocking I/O** : block이 되었을 때, 대기하지 않고 바로 다른 스레드에게 CPU를 넘긴다.

    - ex) 클라이언트 소켓이 쓰기 작업을 위해 준비되지 않았다면, 바로 다른 클라이언트로 change

    - 유용한 상황 : **채팅**

      - 클라이언트가 많고, 각각의 클라이언트가 보내는 데이터가 많지 않고 간헐적으로 보내는 경우

        > 각 커넥션에 대해 스레드를 하나씩 만드는 것은 오버헤드가 많이 발생하게 된다.

      - 만약 **스레드 풀**을 사용한다면...

        > 커넥션이 완전히 종료된 다음에 스레드를 반환하게 되는데, 클라이언트가 계속 연결을 유지하고 있을 경우에는 반환하기까지 너무 시간이 오래 걸린다!

        

- ### 예시

  - RFC 864의 Chargen (Character Generator) Client
    - 클라이언트가 서버에 연결이 되면, 서버는 ASCII 캐릭터를 계속 전송한다.
    - 95개의 아스키 캐릭터 중 72개 + (\r\n), 총 74byte를 계속 전송!
    - **버퍼 재사용** : 매 요청마다 버퍼를 새로 생성하는 것은 성능상 좋지 않으므로, 기존 버퍼를 재사용함
      - `buffer.clear()`를 통해 포지션을 0으로 맞춰 주는 것이 좋다!
      - `clear()`는 포지션만 0으로 보내는 것
      - `flip()`은 포지션도 0으로 보내고, limit을 현재 위치로 맞춰준다.
