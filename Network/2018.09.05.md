# 2018.09.05 Java I/O

### 데몬스레드와 Join 메소드

- **데몬스레드** : 모든 스레드가 종료된 이후에 종료

  main 메소드가 종료되어도 종료되지 않는다. 이런 게 필요할 때 쓴다.

  

- join을 시키면, 새 스레드의 run() 함수가 끝날 때까지 기다린다.

  main()	>	join()	>	wait		>	다음 실행

  ​					>	run		

  - 해당 스레드가 작업을 마치길 기다렸다가 실행해야 하는 경우에 사용한다. (파일 I/O ... )



#### 스레드 그룹

- 스레드를 그룹으로 묶어서 처리하는 것!

- 스레드 그룹을 사용하지 않아도 같은 기능을 할 수 있기 때문에 **PASS**



#### 스레드의 우선순위

- 스레드가 여러 개 있을 때 우선순위가 높은 것을 먼저 실행시킨다.
- 근데 우선순위가 높은 것만 계속 스케줄링되어 실행되는 것은 아니다. OS의 **스케줄러 방식**에 따라 다르다.



#### 멀티스레드와 동기화

- 멀티스레드에서 가장 문제가 될 수 있는 사항은 **동기화**

- 어떤 자원이나 메모리를 공유하고 있는 상황에서 여러 스레드가 해당 자원에 손대면 결과가 이상하게 꼬여버릴 수도!

  > 동기화 처리를 잘 해줘야 한다.

- 이 과정을 잘 이해하기 위해서는 JVM의 데이터 영역을 잘 알고 있어야 함!

  |                           |                                                              |
  | ------------------------- | ------------------------------------------------------------ |
  | PC 레지스터               | - 현재 스레드가 수행하고 있는 코드의 명령과 주소들을 저장.   |
  | JVM 스택 영역             | - 지역변수, 파라미러, 리턴 값과 지역 객체 레퍼런스 저장.     |
  | 네이티브 메소드 스택 영역 | - 사용되는 메소드들 중에 자바가 아닌 애들이 들어간다.<br />- c 스택으로 불린다. JNI의 네이티브 메소드 호출 시 사용된다. |
  | 힙 영역                   | - 생성된 객체들을 저장한다.                                  |
  | 메소드 영역               | - 컴파일된 코드가 들어간다.                                  |
  | 런타임 컨스턴트 풀 영역   | - 각 클래스 또는 인터페이스 클래스 변수, static 변수, 클래스 객체 레퍼런스 저장 |

  - 힙 영역에 공유되는 변수를 레퍼런스 하려 할 때, 모든 객체에 **락(lock)**을 포함시킨다.

  		lock을 가져갈땐, 해당 객체에 접근하고 있는 스레드가 없을 때 가능하다.

  		먼저 해당 객체의 lock을 검사해서, 사용되고 있는지를 확인한 후에 넘긴다.
	
  		사용되고 있을 경우에는 lock이 모니터에 반납될 때까지 기다려야 한다.



- 직접 코딩해서 스레드를 기다리게 만들거나, notify를 통해서 스레드를 깨울 수 있다.